---
title: 面向对象
description: java基础知识
mathjax: true
tags:
  - java
categories:
  - java
abbrlink: 28239a8d
date: 2023-08-10 19:18:02
updated: 2023-10-23 22:00:00
---

# 类
## 类的组成部分
成员变量，成员方法，构造器，（内部类，代码块）
## 标准的javabean类
1.类名需要见名知意
2.成员变量使用private修饰
3.提供至少两个构造方法（无参构造方法和带全部参数的构造方法成员方法）
4.提供每一个成员变量对应的setXxx（）/getXxx（）如果还有其他行为，也需要写上
### 构造方法
方法名与类名需完全一致，没有返回值，创建对象时系统自动调用进行对象的初始化
没有构造方法时默认调用无参构造方法
### 成员变量和局部变量
<img src="/post-img/Pasted image 20230331163238.png" alt="图片损坏" style="zoom:100%;" />

#### this
可以区分成员变量和局部变量，存储的是所在方法调用者的地址值，采用就近原则
## 代码块：
### 局部代码块
变量的作用范围是一对大括号内，提前结束变量的生命周期
### 构造代码块
写在成员位置的代码块，可以把多个构造方法中重复的代码抽取出来；创建本类对象的时候会先执行构造代码块，再执行构造方法
### 静态代码块
通过static关键字修饰，随类的加载而加载，并且自动触发，只执行一次，在类加载的时候，做一些数据初始化的时候使用
## 内部类
### 定义 
定义在一个类里面的类就是内部类，
当B表示的事物是A的一部分，且B单独存在没有意义时，可以将B定义为A的内部类
### 分类
#### 成员内部类
写在成员位置的，属于外部类的成员
##### 获取方法
1.当成员内部类被private修饰时。在外部类编写方法，对外提供内部类对象
2.当成员内部类被非私有修饰时，直接创建对象。
outer.Inner oi = new Outer().new Inner();
3.外部类成员变量和内部类成员变量重名时，用”Outer.this.变量名“访问
#### 静态内部类
是一种特殊的成员内部类
##### 创建对象方式
```java
Outer.Inner oi=new Outer.Inner();
```
##### 调用其中方法
非静态方法：先创建对象，用对象调用
静态方法：外部类名.内部类名.方法名（）；
#### 局部内部类
1.将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。
2.外界无法直接使用，需要在方法内部创建对象并使用。
3.该类可以直接访问外部类的成员，也可以访问方法内的局部变量。
#### 匿名内部类
隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置
##### 格式
```java
//包含了继承或实现，方法重写，创建对象
//整体就是一个类的子类对象或接口的实现对象
//常用于构造函数式接口的实现对象并作为参数传递给方法
//可以理解为一个一次性对象，简化代码，还可以利用lambda表达式进一步简化
new 类名或接口名(){
	重写方法；
} 
```


# 修饰符
## static
### 静态变量
被该类所有对象共享，不属于对象属于类，随着类的加载而加载，优先于对象存在
### 静态方法
多用在测试类和工具类中，javabean类很少使用
#### 调用方式
类名调用，对象调用
#### 工具类
1.类名见名知意
2.私有化构造方法
3.成员方法用static修饰
4.外部无法创建其对象，但是可以调用其中的方法
#### 注意事项
静态方法中，只能访问静态变量;    非静态方法可以访问所有;     静态方法中没有this关键字
<img src="/post-img/Pasted image 20230331172501.png" alt="图片损坏" style="zoom:100%;" />

## final
修饰方法：不能被重写；
修饰类：不能被继承；
修饰变量：常量，只能被赋值一次
常量：全部大写，多个单词间用下划线隔开
修饰基本数据类型，变量存储的数据值不能发生改变
修饰引用数据类型，变量存储的地址值不能发生改变，对象内部的值可以改变

## 权限修饰符
<img src="/post-img/Pasted image 20230403112615.png" alt="图片损坏" style="zoom:100%;" />

# 包
包就是文件夹，用来管理各种不同功能的java类，方便后期代码维护
包名：公司域名反写加包的作用，全英文小写，见名知意
使用同一个包中的类时，不需要导包，使用java.lang包中的类时，不需要导包，其他情况需要
同时使用两个包中的同名类，需要用全类名（包名.类名）

# 接口
## 接口的定义和使用
1.接口是一种规则，是对行为的抽象
2.接口用关键字interface来定义
```java
public interface 接口名{}
```
3.接口不能实例化
4.接口和类之间是实现关系，通过implements关键字表示
```java
public class 类名 implements接口名{}
```
5.接口的子类（实现类)
要么重写接口中的所有抽象方法
要么是抽象类
6.注意:
1.接口和类的实现关系，可以单实现，也可以多实现。
```java
public class 类名 implements 接口名1，接口名2{}
```
2.实现类可以在继承一个类的同时实现多个接口。
```java
public class 类名 extends父类 implements 接口名1，接口名2{}
```
7.接口代表规则，是行为的抽象，想让哪个类拥有一个行为，就让这个类实现对应的接口
8.当一个方法的参数是接口时，可以传递接口所有实现类的对象，称为接口多态
## 接口中成员的特点：
1.成员变量只能是常量（默认修饰符public static final）
2.没有构造方法
3.（JDK7）成员方法只能是抽象方法（默认修饰符public abstract）
4.（JDK8）接口中可以定义有方法体的方法（default，static）  
5.（JDK9）接口中可以定义私有方法  
## 抽象方法
将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容不一样，所以在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。如果一个类中存在抽象方法，那么该类就必须声明为抽象类。
### 抽象类和抽象方法的注意事项
1.抽象类不能实例化
2.抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类可以有构造方法
3.抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类
意义：实现格式的统一
<img src="/post-img/Pasted image 20230403114457.png" alt="图片损坏" style="zoom:100%;" />
<img src="/post-img/Pasted image 20230403114858.png" alt="图片损坏" style="zoom:100%;" />
<img src="/post-img/Pasted image 20230403114950.png" alt="图片损坏" style="zoom:100%;" />
<img src="/post-img/Pasted image 20230403115048.png" alt="图片损坏" style="zoom:100%;" />

# 面向对象三大特征
## 封装
对象代表什么，就得封装对应的数据，并提供数据对应的行为
在java中体现为类的构建
## 继承
### 继承的作用
是面向对象三大特征之一（封装，继承，多态），可以让类与类之间产生子与父的联系
子类可以得到父类的属性和行为并可以使用
<img src="/post-img/Pasted image 20230403085024.png" alt="图片损坏" style="zoom:100%;" />
当类与类之间,存在相同(共性)的内容,并满足子类是父类的一种,就可以考虑使用继承来优化代码

### 继承的特点
1.java只支持单继承，不支持多继承，但支持多层继承（每个子类只有一个父类，每个父类可有多个子类，父类也可作为子类）
2.java中所有的类都直接或间接地继承于object类
3.子类只能访问父类中非私有的成员
4.成员方法的继承采用虚方法表的形式：
虚方法是指不是由private，static，final修饰的方法，子类得到父类中的这些方法后，可以直接使用
子类可以将自己的虚方法添加到自己的虚方法表中，传递给自己的子类，如果有重写的方法，会覆盖
### 方法的重写
当父类的方法不能满足子类现在的需求时，需要进行方法重写
书写格式：
在继承体系中，子类出现了和父类中一模一样的方法声明（方法名，参数），我们就称子类这个方法是重写的方法。
用”@override“检验重写方法时是否有语法错误
注意：
1．重写方法的名称、形参列表必须与父类中的一致。
2．子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 < protected < public )
3．子类重写父类方法时，返回值类型子类必须小于等于父类   
4．建议:重写的方法尽量和父类保持一致
5．只有被添加到虚方法表中的方法才能被重写
### 继承中方法的访问特点
#### 继承中成员方法的访问特点
this就近原则，super直接调用父类
#### 继承中构造方法的访问特点
1.父类的构造方法不能被子类继承
2.子类中所有的构造方法默认先执行父类的无参构造方法，再执行自己
这是因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。
因此子类构造方法的第一行默认是super（），不写也存在，且必须在第一行；如果想调用父类的有参构造，必须手动调用（super（形参））
#### this和super
this理解为一个变量，表示方法调用者的地址值，super代表父类存储空间
<img src="/post-img/Pasted image 20230403091147.png" alt="图片损坏" style="zoom:100%;" />

多态：同类型的对象表现出的不同形态（同一个父类的不同子类）
格式：父类类型 对象名称=子类对象；
前提：有继承（或实现）关系，有方法重写，有父类引用指向子类对象


## 多态
### 多态调用成员的特点
#### 变量调用
编译看左边，运行也看左边
编译代码的时候，会看左边的父类中有没有这个变量，有则编译成功，否则编译失败
运行代码的时候，实际获取的是左边父类中成员变量的值
#### 方法调用
编译看左边，运行看右边
编译代码的时候，会看左边的父类中有没有这个方法，如果有编译成功，否则编译失败
运行的时候实际运行的是子类中的方法
（Animal a =new Dog(),  a.name.sout=动物，a.show=Dog---showf）
<img src="/post-img/Pasted image 20230403111104.png" alt="图片损坏" style="zoom:100%;" />

### 优势和弊端
优势：使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利性
弊端：不能调用子类的特有功能（父类中没有的方法编译时直接报错）
解决方法：将父类类型强转成子类类型，但不能转换成其他类的类型
### instanceof关键字
检验类型是否正确   
格式：变量 instanceof 类名  返回一个boolean

